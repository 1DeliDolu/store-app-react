(Bu dosya, projede thunk'ların nasıl kullanıldığını açıklar; özellikle sepet için kullanılan `addItemToCart` thunk'ı ve bunun `cartSlice.js`, `ProductCard.jsx`, `ProductDetails.jsx` ve `App.jsx` ile nasıl ilişkilendiğine odaklanır.)

## Genel Bakış — Projedeki Thunk'lar

Async (asenkron) işlemler için Redux Toolkit'in `createAsyncThunk` fonksiyonunu kullanıyoruz. Bu, sunucu çağrılarını merkezi bir yerde tutmamıza ve tamamlandığında Redux durumunu güncellememize olanak verir. Projedeki ana örnek `addItemToCart` thunk'ıdır; bu thunk sunucuya ürün ekleme isteği gönderir ve güncellenmiş sepet (cart) objesini döndürür.

İlgili dosyalar:

- `src/pages/cart/cartSlice.js` — `addItemToCart` thunk'ını ve `setCart` reducer'ını içeren cart slice burada tanımlıdır; ayrıca thunk yaşam döngüsünü yöneten extraReducers bulunur.
- `src/components/ProductCard.jsx` — ürün kartından öğe eklemek için `addItemToCart` dispatch eder.
- `src/pages/ProductDetails.jsx` — mevcut hâldeki dosya doğrudan API çağrısı yapıyor; başarı durumunda `setCart` dispatch ediliyor.
- `src/App.jsx` — uygulama yüklendiğinde mevcut sepeti alıp `setCart` ile başlatır.

## `cartSlice.js` — thunk ve slice (nasıl çalışır)

Temel sözleşme (contract):

- Girdi: `{ productId, quantity }` nesnesi (thunk içindeki quantity varsayılanı 1'dir)
- Çıktı: Sunucunun döndürdüğü cart objesi (cartItems içinde ürün detayları bulunan DTO)
- Hata: HTTP veya ağ hatalarında thunk hata fırlatır; bileşenler dispatch sonrası hatayı yakalayabilir.

Temel uygulama (dosyada mevcut olan):

- `addItemToCart` — `createAsyncThunk("cart/addItemToCart", async ({ productId, quantity = 1 }) => { ... })` ile oluşturulur ve `requests.cart.addItem(productId, quantity)` çağırır; sunucudan güncellenmiş sepet döner.

- `cartSlice` — şunları içerir:
  - `setCart` reducer (senkron) — sepeti doğrudan ayarlamak için (başlangıç yüklemesi veya manuel güncellemeler için kullanılır)
  - `extraReducers` — thunk yaşam döngüsünü yönetir:
    - `.pending` durumunda `state.status = "pendingAddItem" + productId` ayarlanır; böylece UI her ürün için ayrı yükleme göstergesi (spinner) gösterebilir.
    - `.fulfilled` olduğunda `state.cart = action.payload` ile sepet güncellenir ve status temizlenir.
    - `.rejected` durumunda status temizlenir.

Neden bu deseni kullanmalıyız?

- Sunucu iletişimini ve durum geçişlerini Redux içinde merkezileştirir.
- Thunk, güncellenmiş sepeti döndürür; slice bunu saklar — bileşenler `state.cart.cart` okuyarak güncel veriyi render eder.

Thunk içindeki tipik akış:

1. Kullanıcı UI'da "Sepete Ekle" butonuna tıklar.
2. Bileşen `dispatch(addItemToCart({ productId }))` yapar.
3. Thunk çalışır, sunucuya POST gönderir (`requests.cart.addItem(...)`).
4. Başarılıysa thunk güncellenmiş sepet ile çözülür; slice `.fulfilled` ile sepeti saklar.
5. UI `state.cart.cart`'ı okuyup otomatik olarak güncellenir.

## `ProductCard.jsx` — thunk'ı dispatch etme

Dosya: `src/components/ProductCard.jsx`

- İçe aktarma: `import { addItemToCart, setCart } from "../pages/cart/cartSlice";`
- `useDispatch()` ve `useSelector(state => state.cart)` kullanarak `status` okunur; böylece `status === "pendingAddItem" + product.id` kontrolü ile her ürün için spinner gösterilebilir.
- Butona tıklandığında `dispatch(addItemToCart({ productId: product.id }))` çağrılır.

Notlar ve iyi uygulamalar:

- Bileşenden doğrudan API çağırmak yerine thunk dispatch etmeyi tercih edin. Bu, ağ mantığını ve hata yönetimini merkezileştirir.
- `status` için kullanılan string kalıbının (`pendingAddItem<id>`) hem slice hem bileşen tarafında birebir aynı şekilde oluşturulduğundan emin olun.

## `ProductDetails.jsx` — iki yaklaşım

Mevcut dosya doğrudan API çağrısı yapıyor:

- `handleAddItem(productId)` içinde `requests.cart.addItem(productId)` doğrudan çağrılıyor ve sonra `dispatch(setCart(cart))` ile durum güncelleniyor.

Bu çözüm çalışır ama ağ mantığının tekrarına neden olur. Önerilen seçenekler:

1. Tutarlılık için manuel çağrıyı thunk ile değiştirin:

- `dispatch(addItemToCart({ productId }))`
- Bileşen düzeyinde yükleme/hata yönetimi gerekiyorsa return edilen promise üzerinde `.unwrap()` kullanabilirsiniz:
  `dispatch(addItemToCart({ productId })).unwrap().then(...).catch(...)`

2. Manuel çağrıyı koruyun ama tekrar eden mantığı ortak bir API helper'a taşıyın.

Neden thunk tercih edilmeli?

- Sunucu etkileşimleri için tek bir doğruluk kaynağı sağlar.
- Hata yönetimi ve yükleme durumu Redux slice içinde tutulur; herhangi bir bileşen bunu gözlemleyebilir.

Önerilen değişiklik örneği (`ProductDetails` içinde):

```javascript
function handleAddItem(productId) {
  setIsAdding(true);
  dispatch(addItemToCart({ productId }))
    .unwrap()
    .catch((err) => console.log(err))
    .finally(() => setIsAdding(false));
}
```

`.unwrap()` kullanmak, thunk'ın başarı değeriyle çözülen veya hata ile reddedilen normal bir promise döndürmesini sağlar; bileşen tarafında hata yönetimi için kullanışlıdır.

## `App.jsx` — başlangıçta sepeti yükleme

Mevcut: `App.jsx` mount edildiğinde `requests.cart.get().then(cart => dispatch(setCart(cart)))` ile sepeti alıp başlatıyor.

Öneri:

- Bu doğrudan GET çağrısını tutabilirsiniz — basit bir başlangıç adımı için uygundur.
- Alternatif olarak, tutarlılık amacıyla bir `getCart` thunk oluşturup `App.jsx` içinde `dispatch(getCart())` yapabilirsiniz. Örnek:

```javascript
export const getCart = createAsyncThunk("cart/getCart", async () => {
  return await requests.cart.get();
});
```

ve `App.jsx` içinde `dispatch(getCart())` çağrısı yapabilirsiniz.

## Kenar durumlar ve hata ayıklama

- Yeniden deklarasyon / çift import hataları: `cartSlice.js` içinde tek bir import bloğu bulunduğundan ve dosyada tekrarlı kod olmadığından emin olun. "redeclaration of import createAsyncThunk" gibi bir hata görürseniz `cartSlice.js` dosyasını açıp tekrar eden importları kaldırın.
- Eksik export hataları: `cartSlice.js`'in import etmeye çalıştığınız isimleri gerçekten export ettiğini doğrulayın (ör. `export const addItemToCart = ...` ve `export const { setCart } = cartSlice.actions`). Eğer `export default cartSlice.reducer` kullanıyorsanız reducer'ı `store.js` içinde default import ile ekleyin.
- UI hemen güncellenmiyorsa: bazı bileşenler Redux yerine `CartContext` kullanıyor olabilir. Tek bir kaynak (Redux) kullanmak tercih edilir. Geçici çözüm olarak dispatch başarılı olduktan sonra context setter çağrılarak senkronizasyon sağlanabilir; ama uzun vadede Context'i kaldırıp tekilleştirmek daha temiz bir çözümdür.
- Ürün bazlı spinner eşleşmemesi: `status` stringinin hem thunk'ın pending kısmında hem de bileşenin selector'unda birebir aynı şekilde oluşturulduğundan emin olun (örneğin `"pendingAddItem" + product.id`).

## Manuel API çağrılarını thunk'lara çevirme için kısa kontrol listesi

1. `cartSlice.js` içinde `addItemToCart` thunk'ı yoksa oluşturun.
2. Bileşenlerde `requests.cart.addItem(...)` + `dispatch(setCart(...))` kullanımını `dispatch(addItemToCart({ productId }))` ile değiştirin.
3. Bileşen düzeyinde yanıt beklemeniz ve hataları yerelde yönetmeniz gerekiyorsa `.unwrap()` kullanın.
4. Eğer proje içinde hem `CartContext` hem Redux varsa, Context kullanımını kaldırın ya da başarılı dispatch sonrası context setter ile güncelleyin (geçici çözüm).

## Örnek: bir bileşende `.unwrap()` kullanımı

```javascript
dispatch(addItemToCart({ productId }))
  .unwrap()
  .then((cart) => {
    // cart: sunucudan dönen güncellenmiş sepet
  })
  .catch((err) => {
    // hata yönetimi
  });
```

## Son notlar

Ağ (network) mantığını thunk'lar içinde tutmak, bileşenleri basitleştirir ve durum değişikliklerini merkezileştirir. Bu projede `addItemToCart` thunk'ını `ProductCard` ve `ProductDetails` gibi bileşenlerde kullanmayı; `setCart`'ı ise sadece başlangıç yüklemesi veya özel durumlar için kullanmayı öneririm.

İsterseniz ben aşağıdakileri uygulayabilirim:

- `ProductDetails.jsx` içindeki manuel `requests.cart.addItem(...)` çağrısını `dispatch(addItemToCart(...))` ile değiştirip `.unwrap()` ile lokal yükleme durumunu yöneteyim; ve/veya
- `getCart` thunk'ını ekleyip `App.jsx` içinde `dispatch(getCart())` kullanarak başlangıç yüklemesini thunk ile yapayım.
